/* tslint:disable */
/* eslint-disable */
/**
 * 
 * 
 *
 * 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Acl
 */
export interface Acl {
    /**
     * 
     * @type {Array<string>}
     * @memberof Acl
     */
    'viewers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Acl
     */
    'owners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'contactEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'img'?: string;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'url'?: string;
    /**
     * 
     * @type {Filter}
     * @memberof Action
     */
    'filter'?: Filter;
    /**
     * 
     * @type {ActionCreatedOnEpoch}
     * @memberof Action
     */
    'createdOnEpoch'?: ActionCreatedOnEpoch;
}
/**
 * 
 * @export
 * @interface ActionCreatedOnEpoch
 */
export interface ActionCreatedOnEpoch {
    /**
     * 
     * @type {number}
     * @memberof ActionCreatedOnEpoch
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionCreatedOnEpoch
     */
    'nanos'?: number;
}
/**
 * An error that occurs during normal application logic
 * @export
 * @interface AppError
 */
export interface AppError {
    /**
     * 
     * @type {number}
     * @memberof AppError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AppError
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppError
     */
    'message'?: string;
}
/**
 * Connected outer service information.
 * @export
 * @interface ConnectedOuterService
 */
export interface ConnectedOuterService {
    /**
     * Connected outer service name.
     * @type {string}
     * @memberof ConnectedOuterService
     */
    'name'?: string;
    /**
     * Connected outer service version.
     * @type {string}
     * @memberof ConnectedOuterService
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CreateAction
 */
export interface CreateAction {
    /**
     * 
     * @type {string}
     * @memberof CreateAction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAction
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAction
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAction
     */
    'contactEmail'?: string;
    /**
     * Reference link to an image file that can be usd in an UI to represent the action.
     * @type {string}
     * @memberof CreateAction
     */
    'img'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAction
     */
    'url'?: string;
    /**
     * 
     * @type {Filter}
     * @memberof CreateAction
     */
    'filter'?: Filter;
}
/**
 * 
 * @export
 * @interface CreatedOnEpoch
 */
export interface CreatedOnEpoch {
    /**
     * 
     * @type {number}
     * @memberof CreatedOnEpoch
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreatedOnEpoch
     */
    'nanos'?: number;
}
/**
 * 
 * @export
 * @interface Data
 */
export interface Data {
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof Data
     */
    'uri'?: string;
}
/**
 * 
 * @export
 * @interface Ddms
 */
export interface Ddms {
    /**
     * 
     * @type {string}
     * @memberof Ddms
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ddms
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ddms
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Ddms
     */
    'contactEmail'?: string;
    /**
     * 
     * @type {Array<DdmsInterface>}
     * @memberof Ddms
     */
    'interfaces'?: Array<DdmsInterface>;
}
/**
 * 
 * @export
 * @interface DdmsInterface
 */
export interface DdmsInterface {
    /**
     * 
     * @type {string}
     * @memberof DdmsInterface
     */
    'entityType'?: string;
    /**
     * 
     * @type {object}
     * @memberof DdmsInterface
     */
    'schema': object;
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorModel
     */
    'errors'?: Array<Error>;
    /**
     * 
     * @type {number}
     * @memberof ErrorModel
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    'message'?: string;
}
/**
 * An error that occurs during normal application logic
 * @export
 * @interface ErrorResponseFormat
 */
export interface ErrorResponseFormat {
    /**
     * 
     * @type {ErrorModel}
     * @memberof ErrorResponseFormat
     */
    'error'?: ErrorModel;
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    'entityType'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    'source'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Filter
     */
    'version'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetSubscriptionResult
 */
export interface GetSubscriptionResult {
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'topic'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'pushEndpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubscriptionResult
     */
    'notificationId'?: string;
}
/**
 * 
 * @export
 * @interface Legal
 */
export interface Legal {
    /**
     * 
     * @type {Array<string>}
     * @memberof Legal
     */
    'legaltags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Legal
     */
    'otherRelevantDataCountries'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'domain'?: string;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'kind'?: string;
    /**
     * 
     * @type {Acl}
     * @memberof Record
     */
    'acl'?: Acl;
    /**
     * 
     * @type {Legal}
     * @memberof Record
     */
    'legal'?: Legal;
    /**
     * 
     * @type {Data}
     * @memberof Record
     */
    'data'?: Data;
}
/**
 * 
 * @export
 * @interface ResponseEntity
 */
export interface ResponseEntity {
    /**
     * 
     * @type {object}
     * @memberof ResponseEntity
     */
    'body'?: object;
    /**
     * 
     * @type {string}
     * @memberof ResponseEntity
     */
    'statusCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseEntity
     */
    'statusCodeValue'?: number;
}
/**
 * Schema authority source and type description
 * @export
 * @interface SchemaIdentity
 */
export interface SchemaIdentity {
    /**
     * Entity authority
     * @type {string}
     * @memberof SchemaIdentity
     */
    'authority': string;
    /**
     * EntityType Code
     * @type {string}
     * @memberof SchemaIdentity
     */
    'entityType': string;
    /**
     * A read-only system defined id used for referencing of a schema.
     * @type {string}
     * @memberof SchemaIdentity
     */
    'id'?: string;
    /**
     * Major Schema Version Number
     * @type {number}
     * @memberof SchemaIdentity
     */
    'schemaVersionMajor': number;
    /**
     * Minor Schema Version Number
     * @type {number}
     * @memberof SchemaIdentity
     */
    'schemaVersionMinor': number;
    /**
     * Patch Schema Version Number
     * @type {number}
     * @memberof SchemaIdentity
     */
    'schemaVersionPatch': number;
    /**
     * Entity source
     * @type {string}
     * @memberof SchemaIdentity
     */
    'source': string;
}
/**
 * Schema info including status, creation and schemaIdentity
 * @export
 * @interface SchemaInfo
 */
export interface SchemaInfo {
    /**
     * The user who created the schema. This value is taken from API caller token.
     * @type {string}
     * @memberof SchemaInfo
     */
    'createdBy'?: string;
    /**
     * The UTC date time of the entity creation
     * @type {string}
     * @memberof SchemaInfo
     */
    'dateCreated'?: string;
    /**
     * 
     * @type {SchemaIdentity}
     * @memberof SchemaInfo
     */
    'schemaIdentity': SchemaIdentity;
    /**
     * Schema Scope - is it internal or shared. This is a system defined attribute based on partition-id passed.
     * @type {string}
     * @memberof SchemaInfo
     */
    'scope'?: SchemaInfoScopeEnum;
    /**
     * Schema lifecycle status
     * @type {string}
     * @memberof SchemaInfo
     */
    'status': SchemaInfoStatusEnum;
    /**
     * 
     * @type {SchemaIdentity}
     * @memberof SchemaInfo
     */
    'supersededBy'?: SchemaIdentity;
}

export const SchemaInfoScopeEnum = {
    Internal: 'INTERNAL',
    Shared: 'SHARED'
} as const;

export type SchemaInfoScopeEnum = typeof SchemaInfoScopeEnum[keyof typeof SchemaInfoScopeEnum];
export const SchemaInfoStatusEnum = {
    Published: 'PUBLISHED',
    Obsolete: 'OBSOLETE',
    Development: 'DEVELOPMENT'
} as const;

export type SchemaInfoStatusEnum = typeof SchemaInfoStatusEnum[keyof typeof SchemaInfoStatusEnum];

/**
 * The response for a GET schema request
 * @export
 * @interface SchemaInfoResponse
 */
export interface SchemaInfoResponse {
    /**
     * 
     * @type {Array<SchemaInfo>}
     * @memberof SchemaInfoResponse
     */
    'schemaInfos'?: Array<SchemaInfo>;
    /**
     * The offset for the next query
     * @type {number}
     * @memberof SchemaInfoResponse
     */
    'offset'?: number;
    /**
     * The number of schema versions in this response
     * @type {number}
     * @memberof SchemaInfoResponse
     */
    'count'?: number;
    /**
     * The total number of entity type codes in the repositories
     * @type {number}
     * @memberof SchemaInfoResponse
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface SchemaRequest
 */
export interface SchemaRequest {
    /**
     * 
     * @type {object}
     * @memberof SchemaRequest
     */
    'schema': object;
    /**
     * 
     * @type {SchemaInfo}
     * @memberof SchemaRequest
     */
    'schemaInfo': SchemaInfo;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'secretType'?: SecretSecretTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof Secret
     */
    'value'?: object;
}

export const SecretSecretTypeEnum = {
    Hmac: 'HMAC',
    Gsa: 'GSA'
} as const;

export type SecretSecretTypeEnum = typeof SecretSecretTypeEnum[keyof typeof SecretSecretTypeEnum];

/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'topic'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'pushEndpoint'?: string;
    /**
     * 
     * @type {Secret}
     * @memberof Subscription
     */
    'secret'?: Secret;
}
/**
 * 
 * @export
 * @interface SubscriptionCreateResult
 */
export interface SubscriptionCreateResult {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'topic'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'pushEndpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionCreateResult
     */
    'notificationId'?: string;
    /**
     * 
     * @type {CreatedOnEpoch}
     * @memberof SubscriptionCreateResult
     */
    'createdOnEpoch'?: CreatedOnEpoch;
    /**
     * 
     * @type {Secret}
     * @memberof SubscriptionCreateResult
     */
    'secret'?: Secret;
}
/**
 * 
 * @export
 * @interface TestAction
 */
export interface TestAction {
    /**
     * 
     * @type {CreateAction}
     * @memberof TestAction
     */
    'action'?: CreateAction;
    /**
     * 
     * @type {object}
     * @memberof TestAction
     */
    'testPayload'?: object;
}
/**
 * 
 * @export
 * @interface TestActionResult
 */
export interface TestActionResult {
    /**
     * 
     * @type {string}
     * @memberof TestActionResult
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestActionResult
     */
    'errors'?: string;
}
/**
 * 
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Topic
     */
    'state'?: string;
    /**
     * 
     * @type {Array<TopicExample>}
     * @memberof Topic
     */
    'example'?: Array<TopicExample>;
}
/**
 * 
 * @export
 * @interface TopicExample
 */
export interface TopicExample {
    /**
     * 
     * @type {string}
     * @memberof TopicExample
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopicExample
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof TopicExample
     */
    'op'?: string;
}
/**
 * Version info.
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * Maven artifact group ID.
     * @type {string}
     * @memberof VersionInfo
     */
    'groupId'?: string;
    /**
     * Maven artifact ID.
     * @type {string}
     * @memberof VersionInfo
     */
    'actifactId'?: string;
    /**
     * Maven artifact version
     * @type {string}
     * @memberof VersionInfo
     */
    'version'?: string;
    /**
     * Maven artifact build time
     * @type {string}
     * @memberof VersionInfo
     */
    'buildTime'?: string;
    /**
     * Current git branch
     * @type {string}
     * @memberof VersionInfo
     */
    'branch'?: string;
    /**
     * Latest commit hash
     * @type {string}
     * @memberof VersionInfo
     */
    'commitId'?: string;
    /**
     * Latest commit message
     * @type {string}
     * @memberof VersionInfo
     */
    'commitMessage'?: string;
    /**
     * Connected outer services information
     * @type {Array<ConnectedOuterService>}
     * @memberof VersionInfo
     */
    'connectedOuterServices'?: Array<ConnectedOuterService>;
}

/**
 * ActionApi - axios parameter creator
 * @export
 */
export const ActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an action registration. Required role: \'users.datalake.admins\'
         * @summary Create an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {CreateAction} [createAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActionRegistration: async (dataPartitionId: string, createAction?: CreateAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('createAnActionRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/action`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an action registration with the given id. Required role: \'users.datalake.admins\'
         * @summary Delete an action  registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnActionRegistration: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAnActionRegistration', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('deleteAnActionRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/action/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an action registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get an action registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnActionRegistration: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAnActionRegistration', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('getAnActionRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/action/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for action registrations and substitutes any action with the given parameters
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Record} [record] The Record to find matching actions for and apply the template for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAnActionRegistration: async (dataPartitionId: string, record?: Record, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('retrieveAnActionRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/action:retrieve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(record, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Test an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {TestAction} [testAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAnActionRegistration: async (dataPartitionId: string, testAction?: TestAction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('testAnActionRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/action:test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testAction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionApi - functional programming interface
 * @export
 */
export const ActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an action registration. Required role: \'users.datalake.admins\'
         * @summary Create an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {CreateAction} [createAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnActionRegistration(dataPartitionId: string, createAction?: CreateAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnActionRegistration(dataPartitionId, createAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an action registration with the given id. Required role: \'users.datalake.admins\'
         * @summary Delete an action  registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnActionRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnActionRegistration(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an action registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get an action registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnActionRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Action>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnActionRegistration(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for action registrations and substitutes any action with the given parameters
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Record} [record] The Record to find matching actions for and apply the template for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAnActionRegistration(dataPartitionId: string, record?: Record, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Action>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAnActionRegistration(dataPartitionId, record, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Test an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {TestAction} [testAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAnActionRegistration(dataPartitionId: string, testAction?: TestAction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestActionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testAnActionRegistration(dataPartitionId, testAction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActionApi - factory interface
 * @export
 */
export const ActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionApiFp(configuration)
    return {
        /**
         * Create an action registration. Required role: \'users.datalake.admins\'
         * @summary Create an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {CreateAction} [createAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnActionRegistration(dataPartitionId: string, createAction?: CreateAction, options?: any): AxiosPromise<Action> {
            return localVarFp.createAnActionRegistration(dataPartitionId, createAction, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an action registration with the given id. Required role: \'users.datalake.admins\'
         * @summary Delete an action  registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnActionRegistration(id: string, dataPartitionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAnActionRegistration(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an action registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get an action registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnActionRegistration(id: string, dataPartitionId: string, options?: any): AxiosPromise<Action> {
            return localVarFp.getAnActionRegistration(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for action registrations and substitutes any action with the given parameters
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Record} [record] The Record to find matching actions for and apply the template for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAnActionRegistration(dataPartitionId: string, record?: Record, options?: any): AxiosPromise<Array<Action>> {
            return localVarFp.retrieveAnActionRegistration(dataPartitionId, record, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Test an action registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {TestAction} [testAction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAnActionRegistration(dataPartitionId: string, testAction?: TestAction, options?: any): AxiosPromise<TestActionResult> {
            return localVarFp.testAnActionRegistration(dataPartitionId, testAction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionApi - object-oriented interface
 * @export
 * @class ActionApi
 * @extends {BaseAPI}
 */
export class ActionApi extends BaseAPI {
    /**
     * Create an action registration. Required role: \'users.datalake.admins\'
     * @summary Create an action registration
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {CreateAction} [createAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public createAnActionRegistration(dataPartitionId: string, createAction?: CreateAction, options?: AxiosRequestConfig) {
        return ActionApiFp(this.configuration).createAnActionRegistration(dataPartitionId, createAction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an action registration with the given id. Required role: \'users.datalake.admins\'
     * @summary Delete an action  registration
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public deleteAnActionRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return ActionApiFp(this.configuration).deleteAnActionRegistration(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an action registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Get an action registration
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public getAnActionRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return ActionApiFp(this.configuration).getAnActionRegistration(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Query for action registrations and substitutes any action with the given parameters
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {Record} [record] The Record to find matching actions for and apply the template for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public retrieveAnActionRegistration(dataPartitionId: string, record?: Record, options?: AxiosRequestConfig) {
        return ActionApiFp(this.configuration).retrieveAnActionRegistration(dataPartitionId, record, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test an action registration. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Test an action registration
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {TestAction} [testAction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionApi
     */
    public testAnActionRegistration(dataPartitionId: string, testAction?: TestAction, options?: AxiosRequestConfig) {
        return ActionApiFp(this.configuration).testAnActionRegistration(dataPartitionId, testAction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainDataManagementServiceDDMSApi - axios parameter creator
 * @export
 */
export const DomainDataManagementServiceDDMSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a DDMS registration using an OpenApi spec V3 document. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a DDMS registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Ddms} [ddms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createADDMSRegistration: async (dataPartitionId: string, ddms?: Ddms, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('createADDMSRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/ddms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ddms, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a DDMS registration with the given id. Required roles: \'users.datalake.admins\'
         * @summary Delete a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteADDMSRegistration: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteADDMSRegistration', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('deleteADDMSRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/ddms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a DDMS registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getADDMSRegistration: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getADDMSRegistration', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('getADDMSRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/ddms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for DDMS registrations allowing retrievals by type. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for DDMS registrations
         * @param {string} type 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryADDMSRegistration: async (type: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('queryADDMSRegistration', 'type', type)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('queryADDMSRegistration', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/ddms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Single DDMS record id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Retrieves Single Entity record id
         * @param {string} id 
         * @param {string} type Specifies the type in ddms I.E wellbores
         * @param {string} localid Specifies the record id with Optional version partition-id:group-type--IndividualType:UniqueRecordID:&lt;OptionalVersionNumber&gt;
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievesSingleEntityRecordId: async (id: string, type: string, localid: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievesSingleEntityRecordId', 'id', id)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('retrievesSingleEntityRecordId', 'type', type)
            // verify required parameter 'localid' is not null or undefined
            assertParamExists('retrievesSingleEntityRecordId', 'localid', localid)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('retrievesSingleEntityRecordId', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/ddms/{id}/{type}/{localid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"localid"}}`, encodeURIComponent(String(localid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainDataManagementServiceDDMSApi - functional programming interface
 * @export
 */
export const DomainDataManagementServiceDDMSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainDataManagementServiceDDMSApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a DDMS registration using an OpenApi spec V3 document. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a DDMS registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Ddms} [ddms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createADDMSRegistration(dataPartitionId: string, ddms?: Ddms, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ddms>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createADDMSRegistration(dataPartitionId, ddms, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a DDMS registration with the given id. Required roles: \'users.datalake.admins\'
         * @summary Delete a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteADDMSRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteADDMSRegistration(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a DDMS registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getADDMSRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ddms>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getADDMSRegistration(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query for DDMS registrations allowing retrievals by type. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for DDMS registrations
         * @param {string} type 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryADDMSRegistration(type: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ddms>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryADDMSRegistration(type, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Single DDMS record id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Retrieves Single Entity record id
         * @param {string} id 
         * @param {string} type Specifies the type in ddms I.E wellbores
         * @param {string} localid Specifies the record id with Optional version partition-id:group-type--IndividualType:UniqueRecordID:&lt;OptionalVersionNumber&gt;
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievesSingleEntityRecordId(id: string, type: string, localid: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievesSingleEntityRecordId(id, type, localid, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainDataManagementServiceDDMSApi - factory interface
 * @export
 */
export const DomainDataManagementServiceDDMSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainDataManagementServiceDDMSApiFp(configuration)
    return {
        /**
         * Create a DDMS registration using an OpenApi spec V3 document. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a DDMS registration
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Ddms} [ddms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createADDMSRegistration(dataPartitionId: string, ddms?: Ddms, options?: any): AxiosPromise<Ddms> {
            return localVarFp.createADDMSRegistration(dataPartitionId, ddms, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a DDMS registration with the given id. Required roles: \'users.datalake.admins\'
         * @summary Delete a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteADDMSRegistration(id: string, dataPartitionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteADDMSRegistration(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a DDMS registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a DDMS registration
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getADDMSRegistration(id: string, dataPartitionId: string, options?: any): AxiosPromise<Ddms> {
            return localVarFp.getADDMSRegistration(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for DDMS registrations allowing retrievals by type. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Query for DDMS registrations
         * @param {string} type 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryADDMSRegistration(type: string, dataPartitionId: string, options?: any): AxiosPromise<Array<Ddms>> {
            return localVarFp.queryADDMSRegistration(type, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Single DDMS record id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Retrieves Single Entity record id
         * @param {string} id 
         * @param {string} type Specifies the type in ddms I.E wellbores
         * @param {string} localid Specifies the record id with Optional version partition-id:group-type--IndividualType:UniqueRecordID:&lt;OptionalVersionNumber&gt;
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievesSingleEntityRecordId(id: string, type: string, localid: string, dataPartitionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.retrievesSingleEntityRecordId(id, type, localid, dataPartitionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainDataManagementServiceDDMSApi - object-oriented interface
 * @export
 * @class DomainDataManagementServiceDDMSApi
 * @extends {BaseAPI}
 */
export class DomainDataManagementServiceDDMSApi extends BaseAPI {
    /**
     * Create a DDMS registration using an OpenApi spec V3 document. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Create a DDMS registration
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {Ddms} [ddms] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainDataManagementServiceDDMSApi
     */
    public createADDMSRegistration(dataPartitionId: string, ddms?: Ddms, options?: AxiosRequestConfig) {
        return DomainDataManagementServiceDDMSApiFp(this.configuration).createADDMSRegistration(dataPartitionId, ddms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a DDMS registration with the given id. Required roles: \'users.datalake.admins\'
     * @summary Delete a DDMS registration
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainDataManagementServiceDDMSApi
     */
    public deleteADDMSRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return DomainDataManagementServiceDDMSApiFp(this.configuration).deleteADDMSRegistration(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a DDMS registration with the given id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Get a DDMS registration
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainDataManagementServiceDDMSApi
     */
    public getADDMSRegistration(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return DomainDataManagementServiceDDMSApiFp(this.configuration).getADDMSRegistration(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for DDMS registrations allowing retrievals by type. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Query for DDMS registrations
     * @param {string} type 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainDataManagementServiceDDMSApi
     */
    public queryADDMSRegistration(type: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return DomainDataManagementServiceDDMSApiFp(this.configuration).queryADDMSRegistration(type, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Single DDMS record id. Required roles: \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Retrieves Single Entity record id
     * @param {string} id 
     * @param {string} type Specifies the type in ddms I.E wellbores
     * @param {string} localid Specifies the record id with Optional version partition-id:group-type--IndividualType:UniqueRecordID:&lt;OptionalVersionNumber&gt;
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainDataManagementServiceDDMSApi
     */
    public retrievesSingleEntityRecordId(id: string, type: string, localid: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return DomainDataManagementServiceDDMSApiFp(this.configuration).retrievesSingleEntityRecordId(id, type, localid, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PubsubEndpointApi - axios parameter creator
 * @export
 */
export const PubsubEndpointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary recordChanged
         * @param {string} dataPartitionId tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordChangedUsingPOST: async (dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('recordChangedUsingPOST', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/push-handlers/records-changed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PubsubEndpointApi - functional programming interface
 * @export
 */
export const PubsubEndpointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PubsubEndpointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary recordChanged
         * @param {string} dataPartitionId tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordChangedUsingPOST(dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordChangedUsingPOST(dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PubsubEndpointApi - factory interface
 * @export
 */
export const PubsubEndpointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PubsubEndpointApiFp(configuration)
    return {
        /**
         * 
         * @summary recordChanged
         * @param {string} dataPartitionId tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordChangedUsingPOST(dataPartitionId: string, options?: any): AxiosPromise<ResponseEntity> {
            return localVarFp.recordChangedUsingPOST(dataPartitionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PubsubEndpointApi - object-oriented interface
 * @export
 * @class PubsubEndpointApi
 * @extends {BaseAPI}
 */
export class PubsubEndpointApi extends BaseAPI {
    /**
     * 
     * @summary recordChanged
     * @param {string} dataPartitionId tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PubsubEndpointApi
     */
    public recordChangedUsingPOST(dataPartitionId: string, options?: AxiosRequestConfig) {
        return PubsubEndpointApiFp(this.configuration).recordChangedUsingPOST(dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a schema to the schema repository. The schemaIdentity must be unique. The `authority`, `source` and `entityType` will be registered if not present. If lower minor versions are registered the service validates the new schema against breaking changes; if breaking changes are discovered the request fails. **Note:** The schema must not reference other schemas with status `DEVELOPMENT`. Scope to a schema will be set by system based on partition id (`SHARED` for common tenant and `INTERNAL` for private tenant). Required roles \'users.datalake.editors\' or \'users.datalake.admins\' groups to create schema.
         * @summary Adds a schema to the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest Schema description and schema to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchema: async (dataPartitionId: string, schemaRequest: SchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('createSchema', 'dataPartitionId', dataPartitionId)
            // verify required parameter 'schemaRequest' is not null or undefined
            assertParamExists('createSchema', 'schemaRequest', schemaRequest)
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a schema using its system defined id. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Gets schema from the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} id the system id of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (dataPartitionId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('getSchema', 'dataPartitionId', dataPartitionId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchema', 'id', id)
            const localVarPath = `/schema/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for information of available schema (SchemInfo) in schema repository. Supports options to filter out the search contents. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Searches schemaInfo repository
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} [authority] pass an optional string to search for a specific authority
         * @param {string} [source] pass an optional string to search for a specific source
         * @param {string} [entityType] pass an optional string to search for a specific entityType
         * @param {string} [schemaVersionMajor] pass an optional string to search for a specific schemaVersionMajor
         * @param {string} [schemaVersionMinor] pass an optional string to search for a specific schemaVersionMinor
         * @param {'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE'} [status] The schema status specification
         * @param {'SHARED' | 'INTERNAL'} [scope] The scope or schema visibility specification
         * @param {boolean} [latestVersion] if True, only return the latest version
         * @param {number} [limit] maximum number of schema records to return
         * @param {number} [offset] number of records to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSchemaInfoRepository: async (dataPartitionId: string, authority?: string, source?: string, entityType?: string, schemaVersionMajor?: string, schemaVersionMinor?: string, status?: 'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE', scope?: 'SHARED' | 'INTERNAL', latestVersion?: boolean, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('searchSchemaInfoRepository', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authority !== undefined) {
                localVarQueryParameter['authority'] = authority;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (schemaVersionMajor !== undefined) {
                localVarQueryParameter['schemaVersionMajor'] = schemaVersionMajor;
            }

            if (schemaVersionMinor !== undefined) {
                localVarQueryParameter['schemaVersionMinor'] = schemaVersionMinor;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create/update a schema with status other then `DEVELOPMENT`, API will throw an exception. Any schema instance with the same schemaIdentity is replaced (in contrast to the immutability of `PUBLISHED` or `OBSOLETE` schemas). A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schemas. Scope for a schema can\'t be updated, its a system defined value. Required roles  \'users.datalake.editors\' or \'users.datalake.admins\' groups to update schema.
         * @summary Creates/Updates a schema in development status
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema: async (dataPartitionId: string, schemaRequest: SchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('updateSchema', 'dataPartitionId', dataPartitionId)
            // verify required parameter 'schemaRequest' is not null or undefined
            assertParamExists('updateSchema', 'schemaRequest', schemaRequest)
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a schema to the schema repository. The schemaIdentity must be unique. The `authority`, `source` and `entityType` will be registered if not present. If lower minor versions are registered the service validates the new schema against breaking changes; if breaking changes are discovered the request fails. **Note:** The schema must not reference other schemas with status `DEVELOPMENT`. Scope to a schema will be set by system based on partition id (`SHARED` for common tenant and `INTERNAL` for private tenant). Required roles \'users.datalake.editors\' or \'users.datalake.admins\' groups to create schema.
         * @summary Adds a schema to the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest Schema description and schema to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchema(dataPartitionId, schemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a schema using its system defined id. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Gets schema from the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} id the system id of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(dataPartitionId: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(dataPartitionId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for information of available schema (SchemInfo) in schema repository. Supports options to filter out the search contents. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Searches schemaInfo repository
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} [authority] pass an optional string to search for a specific authority
         * @param {string} [source] pass an optional string to search for a specific source
         * @param {string} [entityType] pass an optional string to search for a specific entityType
         * @param {string} [schemaVersionMajor] pass an optional string to search for a specific schemaVersionMajor
         * @param {string} [schemaVersionMinor] pass an optional string to search for a specific schemaVersionMinor
         * @param {'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE'} [status] The schema status specification
         * @param {'SHARED' | 'INTERNAL'} [scope] The scope or schema visibility specification
         * @param {boolean} [latestVersion] if True, only return the latest version
         * @param {number} [limit] maximum number of schema records to return
         * @param {number} [offset] number of records to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSchemaInfoRepository(dataPartitionId: string, authority?: string, source?: string, entityType?: string, schemaVersionMajor?: string, schemaVersionMinor?: string, status?: 'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE', scope?: 'SHARED' | 'INTERNAL', latestVersion?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSchemaInfoRepository(dataPartitionId, authority, source, entityType, schemaVersionMajor, schemaVersionMinor, status, scope, latestVersion, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create/update a schema with status other then `DEVELOPMENT`, API will throw an exception. Any schema instance with the same schemaIdentity is replaced (in contrast to the immutability of `PUBLISHED` or `OBSOLETE` schemas). A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schemas. Scope for a schema can\'t be updated, its a system defined value. Required roles  \'users.datalake.editors\' or \'users.datalake.admins\' groups to update schema.
         * @summary Creates/Updates a schema in development status
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchema(dataPartitionId, schemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * Adds a schema to the schema repository. The schemaIdentity must be unique. The `authority`, `source` and `entityType` will be registered if not present. If lower minor versions are registered the service validates the new schema against breaking changes; if breaking changes are discovered the request fails. **Note:** The schema must not reference other schemas with status `DEVELOPMENT`. Scope to a schema will be set by system based on partition id (`SHARED` for common tenant and `INTERNAL` for private tenant). Required roles \'users.datalake.editors\' or \'users.datalake.admins\' groups to create schema.
         * @summary Adds a schema to the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest Schema description and schema to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: any): AxiosPromise<SchemaInfo> {
            return localVarFp.createSchema(dataPartitionId, schemaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a schema using its system defined id. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Gets schema from the schema repository.
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} id the system id of the schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(dataPartitionId: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.getSchema(dataPartitionId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for information of available schema (SchemInfo) in schema repository. Supports options to filter out the search contents. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
         * @summary Searches schemaInfo repository
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {string} [authority] pass an optional string to search for a specific authority
         * @param {string} [source] pass an optional string to search for a specific source
         * @param {string} [entityType] pass an optional string to search for a specific entityType
         * @param {string} [schemaVersionMajor] pass an optional string to search for a specific schemaVersionMajor
         * @param {string} [schemaVersionMinor] pass an optional string to search for a specific schemaVersionMinor
         * @param {'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE'} [status] The schema status specification
         * @param {'SHARED' | 'INTERNAL'} [scope] The scope or schema visibility specification
         * @param {boolean} [latestVersion] if True, only return the latest version
         * @param {number} [limit] maximum number of schema records to return
         * @param {number} [offset] number of records to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSchemaInfoRepository(dataPartitionId: string, authority?: string, source?: string, entityType?: string, schemaVersionMajor?: string, schemaVersionMinor?: string, status?: 'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE', scope?: 'SHARED' | 'INTERNAL', latestVersion?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<SchemaInfoResponse> {
            return localVarFp.searchSchemaInfoRepository(dataPartitionId, authority, source, entityType, schemaVersionMajor, schemaVersionMinor, status, scope, latestVersion, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create/update a schema with status other then `DEVELOPMENT`, API will throw an exception. Any schema instance with the same schemaIdentity is replaced (in contrast to the immutability of `PUBLISHED` or `OBSOLETE` schemas). A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schemas. Scope for a schema can\'t be updated, its a system defined value. Required roles  \'users.datalake.editors\' or \'users.datalake.admins\' groups to update schema.
         * @summary Creates/Updates a schema in development status
         * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: any): AxiosPromise<SchemaInfo> {
            return localVarFp.updateSchema(dataPartitionId, schemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * Adds a schema to the schema repository. The schemaIdentity must be unique. The `authority`, `source` and `entityType` will be registered if not present. If lower minor versions are registered the service validates the new schema against breaking changes; if breaking changes are discovered the request fails. **Note:** The schema must not reference other schemas with status `DEVELOPMENT`. Scope to a schema will be set by system based on partition id (`SHARED` for common tenant and `INTERNAL` for private tenant). Required roles \'users.datalake.editors\' or \'users.datalake.admins\' groups to create schema.
     * @summary Adds a schema to the schema repository.
     * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
     * @param {SchemaRequest} schemaRequest Schema description and schema to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public createSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).createSchema(dataPartitionId, schemaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a schema using its system defined id. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
     * @summary Gets schema from the schema repository.
     * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
     * @param {string} id the system id of the schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public getSchema(dataPartitionId: string, id: string, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).getSchema(dataPartitionId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for information of available schema (SchemInfo) in schema repository. Supports options to filter out the search contents. Required roles \'users.datalake.viewers\' or \'users.datalake.editors\' or \'users.datalake.admins\' groups to get the schema.
     * @summary Searches schemaInfo repository
     * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
     * @param {string} [authority] pass an optional string to search for a specific authority
     * @param {string} [source] pass an optional string to search for a specific source
     * @param {string} [entityType] pass an optional string to search for a specific entityType
     * @param {string} [schemaVersionMajor] pass an optional string to search for a specific schemaVersionMajor
     * @param {string} [schemaVersionMinor] pass an optional string to search for a specific schemaVersionMinor
     * @param {'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE'} [status] The schema status specification
     * @param {'SHARED' | 'INTERNAL'} [scope] The scope or schema visibility specification
     * @param {boolean} [latestVersion] if True, only return the latest version
     * @param {number} [limit] maximum number of schema records to return
     * @param {number} [offset] number of records to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public searchSchemaInfoRepository(dataPartitionId: string, authority?: string, source?: string, entityType?: string, schemaVersionMajor?: string, schemaVersionMinor?: string, status?: 'PUBLISHED' | 'DEVELOPMENT' | 'OBSOLETE', scope?: 'SHARED' | 'INTERNAL', latestVersion?: boolean, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).searchSchemaInfoRepository(dataPartitionId, authority, source, entityType, schemaVersionMajor, schemaVersionMinor, status, scope, latestVersion, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create/update a schema with status other then `DEVELOPMENT`, API will throw an exception. Any schema instance with the same schemaIdentity is replaced (in contrast to the immutability of `PUBLISHED` or `OBSOLETE` schemas). A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schemas. Scope for a schema can\'t be updated, its a system defined value. Required roles  \'users.datalake.editors\' or \'users.datalake.admins\' groups to update schema.
     * @summary Creates/Updates a schema in development status
     * @param {string} dataPartitionId Specifies the data partition to use. This should be either the partition name or crm account ID associated with the partition.
     * @param {SchemaRequest} schemaRequest SchemaRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public updateSchema(dataPartitionId: string, schemaRequest: SchemaRequest, options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).updateSchema(dataPartitionId, schemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemasSystemApi - axios parameter creator
 * @export
 */
export const SchemasSystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create a schema with status other then `DEVELOPMENT`, API will not throw an exception. The update of schema without `DEVELOPMENT` status would cause error.Any schema instance with the same schemaIdentity is replaced. A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schema. Scope for a schema will be SHARED for all the schemas created using this API. Service principal authorization is required to call thi API.
         * @summary Creates/Updates a schema in development status
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystemSchema: async (schemaRequest: SchemaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaRequest' is not null or undefined
            assertParamExists('updateSystemSchema', 'schemaRequest', schemaRequest)
            const localVarPath = `/schemas/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schemaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasSystemApi - functional programming interface
 * @export
 */
export const SchemasSystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemasSystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create a schema with status other then `DEVELOPMENT`, API will not throw an exception. The update of schema without `DEVELOPMENT` status would cause error.Any schema instance with the same schemaIdentity is replaced. A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schema. Scope for a schema will be SHARED for all the schemas created using this API. Service principal authorization is required to call thi API.
         * @summary Creates/Updates a schema in development status
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSystemSchema(schemaRequest: SchemaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemaInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSystemSchema(schemaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemasSystemApi - factory interface
 * @export
 */
export const SchemasSystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemasSystemApiFp(configuration)
    return {
        /**
         * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create a schema with status other then `DEVELOPMENT`, API will not throw an exception. The update of schema without `DEVELOPMENT` status would cause error.Any schema instance with the same schemaIdentity is replaced. A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schema. Scope for a schema will be SHARED for all the schemas created using this API. Service principal authorization is required to call thi API.
         * @summary Creates/Updates a schema in development status
         * @param {SchemaRequest} schemaRequest SchemaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystemSchema(schemaRequest: SchemaRequest, options?: any): AxiosPromise<SchemaInfo> {
            return localVarFp.updateSystemSchema(schemaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemasSystemApi - object-oriented interface
 * @export
 * @class SchemasSystemApi
 * @extends {BaseAPI}
 */
export class SchemasSystemApi extends BaseAPI {
    /**
     * Creates a new schema or updates an already existing schema with status `DEVELOPMENT` in the schema repository. If a user tries to create a schema with status other then `DEVELOPMENT`, API will not throw an exception. The update of schema without `DEVELOPMENT` status would cause error.Any schema instance with the same schemaIdentity is replaced. A schema state can also be changed from `DEVELOPMENT` to `PUBLISHED` or `OBSOLETE` while updating schema content or by providing the same schema content. **Note:** The schema may refer to other schema definitions in `DEVELOPMENT` state. If those schemas are updated themselves, it is the developer\'s responsibility to PUT the dependent schemas again to update the schema. Scope for a schema will be SHARED for all the schemas created using this API. Service principal authorization is required to call thi API.
     * @summary Creates/Updates a schema in development status
     * @param {SchemaRequest} schemaRequest SchemaRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasSystemApi
     */
    public updateSystemSchema(schemaRequest: SchemaRequest, options?: AxiosRequestConfig) {
        return SchemasSystemApiFp(this.configuration).updateSystemSchema(schemaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a subscription. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a subscription
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Subscription} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASubscription: async (dataPartitionId: string, subscription?: Subscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('createASubscription', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a subscription with its Id. Required role: \'users.datalake.admins\'
         * @summary Delete a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASubscriptionById: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteASubscriptionById', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('deleteASubscriptionById', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/subscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a subscription with its Id. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASubscriptionById: async (id: string, dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getASubscriptionById', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('getASubscriptionById', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/subscription/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all topics that you can create a subscription for, along with the corresponding sample messages. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary List all topics
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTopics: async (dataPartitionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('listAllTopics', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update secret for a subscription. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Update secret for subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecretForSubscription: async (id: string, dataPartitionId: string, secret?: Secret, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSecretForSubscription', 'id', id)
            // verify required parameter 'dataPartitionId' is not null or undefined
            assertParamExists('updateSecretForSubscription', 'dataPartitionId', dataPartitionId)
            const localVarPath = `/subscription/{id}/secret`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dataPartitionId != null) {
                localVarHeaderParameter['data-partition-id'] = String(dataPartitionId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(secret, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a subscription. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a subscription
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Subscription} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createASubscription(dataPartitionId: string, subscription?: Subscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionCreateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createASubscription(dataPartitionId, subscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a subscription with its Id. Required role: \'users.datalake.admins\'
         * @summary Delete a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteASubscriptionById(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteASubscriptionById(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a subscription with its Id. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getASubscriptionById(id: string, dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSubscriptionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getASubscriptionById(id, dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all topics that you can create a subscription for, along with the corresponding sample messages. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary List all topics
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTopics(dataPartitionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Topic>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTopics(dataPartitionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update secret for a subscription. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Update secret for subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecretForSubscription(id: string, dataPartitionId: string, secret?: Secret, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecretForSubscription(id, dataPartitionId, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * Create a subscription. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Create a subscription
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Subscription} [subscription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createASubscription(dataPartitionId: string, subscription?: Subscription, options?: any): AxiosPromise<SubscriptionCreateResult> {
            return localVarFp.createASubscription(dataPartitionId, subscription, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a subscription with its Id. Required role: \'users.datalake.admins\'
         * @summary Delete a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteASubscriptionById(id: string, dataPartitionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteASubscriptionById(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a subscription with its Id. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Get a subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getASubscriptionById(id: string, dataPartitionId: string, options?: any): AxiosPromise<GetSubscriptionResult> {
            return localVarFp.getASubscriptionById(id, dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all topics that you can create a subscription for, along with the corresponding sample messages. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary List all topics
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTopics(dataPartitionId: string, options?: any): AxiosPromise<Array<Topic>> {
            return localVarFp.listAllTopics(dataPartitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update secret for a subscription. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
         * @summary Update secret for subscription
         * @param {string} id 
         * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
         * @param {Secret} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecretForSubscription(id: string, dataPartitionId: string, secret?: Secret, options?: any): AxiosPromise<void> {
            return localVarFp.updateSecretForSubscription(id, dataPartitionId, secret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * Create a subscription. Required roles: \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Create a subscription
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {Subscription} [subscription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createASubscription(dataPartitionId: string, subscription?: Subscription, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).createASubscription(dataPartitionId, subscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a subscription with its Id. Required role: \'users.datalake.admins\'
     * @summary Delete a subscription
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteASubscriptionById(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).deleteASubscriptionById(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a subscription with its Id. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Get a subscription
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getASubscriptionById(id: string, dataPartitionId: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).getASubscriptionById(id, dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all topics that you can create a subscription for, along with the corresponding sample messages. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary List all topics
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public listAllTopics(dataPartitionId: string, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).listAllTopics(dataPartitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update secret for a subscription. Required role: \'users.datalake.editors\' or \'users.datalake.admins\'
     * @summary Update secret for subscription
     * @param {string} id 
     * @param {string} dataPartitionId Specifies the partition to use. This should be either the partition name associated with the partition.
     * @param {Secret} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateSecretForSubscription(id: string, dataPartitionId: string, secret?: Secret, options?: AxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).updateSecretForSubscription(id, dataPartitionId, secret, options).then((request) => request(this.axios, this.basePath));
    }
}


